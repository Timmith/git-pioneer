var signals = require('signals');
var three = require('three');
var cannon = require('cannon');
var CollisionLayers = require('CollisionLayers');
var geomLib = require('geometry/lib');
var matLib = require('materials/lib');
var BaseGun = require('./tools/BaseGun');

function Portal(world, pos) {
	var radius = 1;
	var geometry = geomLib.sphere(radius, 32, 16);
	var material = matLib.checkerboards(0xffffff*Math.random(), 0xffffff*Math.random());
	material.side = three.BackSide;
	// material.colorWrite = false;

	var shape = new cannon.Sphere(radius);
	var body = new cannon.Body({
		mass: 5 * Math.pow(radius, 3), // kg 
		position: pos,
		type: cannon.Body.DYNAMIC,
		shape: shape,
		linearDamping: 0.6,
		angularDamping: 0.6,
		collisionFilterGroup: CollisionLayers.PORTALS,
		collisionFilterMask: CollisionLayers.ENVIRONMENT | CollisionLayers.PLAYER | CollisionLayers.PORTALS | CollisionLayers.ITEMS
	});
	body.resistGravity = true;

	// body.quaternion.setFromEuler(0, 0, 0);
	var mesh = new three.Mesh(
		geometry,
		material
	);

	body.interactiveObject = { type: "portal", object: this };
	var inside = false;
	var onPlayerEnterSignal = new signals.Signal();
	var onPlayerExitSignal = new signals.Signal();
	this.onPlayerEnterSignal = onPlayerEnterSignal;
	this.onPlayerExitSignal = onPlayerExitSignal;

	this.world = world;
	this.mesh = mesh;
	this.body = body;
	this.onEnterFrame = function onEnterFrame() {
		if(!world.player) return;
		var dist = world.player.camera.localToWorld(new three.Vector3()).sub(mesh.position).length();
		if(!inside && dist < radius * 0.99) {
			inside = true;
			console.log("inside");
			onPlayerEnterSignal.dispatch();
		} else if(inside && dist > radius * 1.01) {
			inside = false;
			console.log("outside");
			onPlayerExitSignal.dispatch();
		}
	}
}

module.exports = Portal;