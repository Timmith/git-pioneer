var three = require('three');
var cannon = require('cannon');
var BaseGun = require('./BaseGun');
var geometryTools = require('geometry/utils');
var CheckerboardTexture = require('threejs-texture-checkerboard');
var decorateMethodBefore = require('utils/decorateMethodBefore');

var GrappleLink = require('../items/GrappleLink');

require('extensions/threeCannon');

function HitScanGrappleLinker(world, pos) {
	var geometry = new three.CylinderGeometry(0.065, 0.035, 1.5, 16, 1);
	var geometry2 = new three.BoxGeometry(0.1, 0.1, 0.4, 1, 1, 4);
	var position = new three.Vector3(0.05, 0, 0.2);
	var orientation = new three.Euler(Math.PI, Math.PI * 0.5, 0);
	geometry2.vertices.forEach(geometryTools.bend(position, orientation, Math.PI * 0.4, 0.4));
	geometry2.computeVertexNormals();
	geometry2.computeFaceNormals();
	var s = 0.35;
	var placeMatrix = new three.Matrix4().compose(
		new three.Vector3(0, -0.72, 0.3 * s),
		new three.Quaternion(),
		new three.Vector3(s, s, s)
	);
	var nubs = 8;
	var grabberGeometry = new three.Geometry();
	for(var i = 0; i < nubs; i++) {
		var nubMatrix = new three.Matrix4().makeRotationY(i/nubs * Math.PI * 2);
		nubMatrix.multiply(placeMatrix);
		grabberGeometry.merge(geometry2, nubMatrix);
	}
	var grabbers = 2;
	s = 0.8;
	placeMatrix = new three.Matrix4().compose(
		new three.Vector3(0, -0.2, 0.1 * s),
		new three.Quaternion(),
		new three.Vector3(s, s, s)
	);
	for(var i = 0; i < grabbers; i++) {
		var grabberMatrix = new three.Matrix4().makeRotationY(i/grabbers * Math.PI * 2);
		grabberMatrix.multiply(placeMatrix);
		geometry.merge(grabberGeometry, grabberMatrix);
	}

	BaseGun.call(this, world, pos, geometry);
	this.primaryFireStart = primaryFireStart.bind(this);
	this.primaryFireEnd = primaryFireEnd.bind(this);
	this.onCannonPostStep = onCannonPostStep.bind(this);
	decorateMethodBefore(this, "onEnterFrameEquipped", onEnterFrame.bind(this));
}

HitScanGrappleLinker.prototype = Object.create(BaseGun.prototype);

var _result = new cannon.RaycastResult();
function hitScan() {
	var from = new three.Vector3();
	var to = new three.Vector3();
	relative.subVectors(this.player.crosshair.localToWorld(to), this.player.camera.localToWorld(from));
	relative.multiplyScalar(100);
	to.add(relative);

	this.world.world.raycastClosest(from, to, {
		skipBackfaces: true
	}, _result);
	if(_result.hasHit && _result.body.type == cannon.Body.DYNAMIC) {
		return _result;
	}
}

var relative = new three.Vector3();
function primaryFireStart(pos, playerSize) {
	var result = hitScan.call(this);
	if(result) {
		with(result) {
			this.world.makeHitEffect(hitPointWorld, playerSize * 0.3, 0.2);

			var grappleBody = new cannon.Body({
				type: cannon.Body.STATIC,
				position: this.player.crosshair2.worldToLocal(new three.Vector3()).toCannon(), // m 
			});
			this.world.world.addBody(grappleBody);

			var spring = new cannon.Spring(grappleBody, body, {
				restLength: 0,
				localAnchorA: new cannon.Vec3(),
				worldAnchorB: result.hitPointWorld
			});

			var geom = new three.SphereGeometry(0.5, 16, 8);
			var t = 0;
			geom.vertices.forEach(v => {
				v.y += 0.5;
				t = v.z;
				v.z = v.y;
				v.y = t;
			});
			var mat = new three.MeshBasicMaterial({
				wireframe: true
			});

			var effect = new three.Mesh(geom, mat);
			this.world.scene.add(effect);

			this.spring = spring;
			this.grappleBody = grappleBody;
			this.effect = effect;
			this.world.world.addEventListener("postStep", this.onCannonPostStep);
		}
	}
}

function primaryFireEnd(pos, playerSize) {
	var spring = this.spring;
	if(spring) {
		var result = hitScan.call(this);
		if(result) {
			with(result) {
				if(spring.bodyB != body) {
					var link = new GrappleLink(this.world, body, spring.bodyB, {
						worldAnchorA: result.hitPointWorld,
						localAnchorB: spring.localAnchorB
					});
					this.world.add(link);
				}
			}
		}
		this.spring = null;
		this.world.world.removeEventListener("postStep", this.onCannonPostStep);
		this.world.world.removeBody(this.grappleBody);
		this.effect.parent.remove(this.effect);

	}
}

function onCannonPostStep(event) {
	this.grappleBody.position.copy(this.player.crosshair2.localToWorld(new three.Vector3()));
	this.spring.applyForce();
}

function onEnterFrame() {
	var tool = this.player.activeTool;
	if(this.spring && tool) {
		this.effect.position.copy(tool.mesh.localToWorld(tool.nozzle.clone()));
		var target = this.spring.bodyB.position.toThree();
		this.effect.lookAt(target);
		var stretch = this.effect.position.clone().sub(target).length();
		var squash = Math.max(1, 1 / stretch);
		this.effect.scale.set(squash, squash, stretch);
	}
}

module.exports = HitScanGrappleLinker;