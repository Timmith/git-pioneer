var three = require('three');
var cannon = require('cannon');
var BaseGun = require('./BaseGun');
var geometryTools = require('geometry/utils');
var CheckerboardTexture = require('threejs-texture-checkerboard');


function HitScanGrappleHook(world, pos) {
	var geometry = new three.CylinderGeometry(0.065, 0.035, 1.5, 16, 1);
	var geometry2 = new three.BoxGeometry(0.1, 0.1, 0.4, 1, 1, 4);
	var position = new three.Vector3(0.05, 0, 0.2);
	var orientation = new three.Euler(Math.PI, Math.PI * 0.5, 0);
	geometry2.vertices.forEach(geometryTools.bend(position, orientation, Math.PI * 0.4, 0.4));
	geometry2.computeVertexNormals();
	geometry2.computeFaceNormals();
	var s = 0.35;
	var placeMatrix = new three.Matrix4().compose(
		new three.Vector3(0, -0.72, 0.3 * s),
		new three.Quaternion(),
		new three.Vector3(s, s, s)
	);
	var nubs = 8;
	for(var i = 0; i < nubs; i++) {
		var nubMatrix = new three.Matrix4().makeRotationY(i/nubs * Math.PI * 2);
		nubMatrix.multiply(placeMatrix);
		geometry.merge(geometry2, nubMatrix);
	}

	BaseGun.call(this, world, pos, geometry);
	this.primaryFire = primaryFire.bind(this);
}

HitScanGrappleHook.prototype = Object.create(BaseGun.prototype);

var relative = new three.Vector3();
var result = new cannon.RaycastResult();
function primaryFire(pos, playerSize) {
	var from = new three.Vector3();
	var to = new three.Vector3();
	relative.subVectors(this.player.crosshair.localToWorld(to), this.player.camera.localToWorld(from));
	relative.multiplyScalar(100);
	to.add(relative);

    this.world.world.raycastClosest(from, to, {
        skipBackfaces: true
    }, result);
    with(result) {
	    if(hasHit) {
	    	this.world.makeHitEffect(hitPointWorld, playerSize);
	    	if(body.type == cannon.Body.DYNAMIC) {
	    		body.applyImpulse(relative, hitPointWorld);
	    	}
	    }
	}
}

module.exports = HitScanGrappleHook;