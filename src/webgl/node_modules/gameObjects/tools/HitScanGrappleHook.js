var three = require('three');
var cannon = require('cannon');
var geomLib = require('geometry/lib');
var matLib = require('materials/lib');
var BaseGun = require('./BaseGun');
var geometryTools = require('geometry/utils');
var CheckerboardTexture = require('threejs-texture-checkerboard');
var decorateMethodBefore = require('utils/decorateMethodBefore');

require('extensions/threeCannon');

function HitScanGrappleHook(world, pos) {
	var geometry = geomLib.gunBase(0.065, 0.035, 1.5, 16, 1).clone();
	var grabber = geomLib.grabber();
	var placeMatrix = new three.Matrix4().makeTranslation(0, -0.76, 0);

	geometry.merge(grabber, placeMatrix);
	var material = matLib.checkerboards.blue();
	BaseGun.call(this, world, pos, geometry, material);
	this.primaryFireStart = primaryFireStart.bind(this);
	this.primaryFireEnd = primaryFireEnd.bind(this);
	this.onCannonPostStep = onCannonPostStep.bind(this);
	decorateMethodBefore(this, "onEnterFrameEquipped", onEnterFrame.bind(this));
}

HitScanGrappleHook.prototype = Object.create(BaseGun.prototype);

var relative = new three.Vector3();
var result = new cannon.RaycastResult();
function primaryFireStart(pos, playerSize) {
	var from = new three.Vector3();
	var to = new three.Vector3();
	relative.subVectors(this.player.crosshair.localToWorld(to), this.player.camera.localToWorld(from));
	relative.multiplyScalar(100);
	to.add(relative);

	this.world.world.raycastClosest(from, to, {
		skipBackfaces: true
	}, result);
	with(result) {
		if(hasHit) {
			if(body.type == cannon.Body.DYNAMIC) {
				this.world.makeHitEffect(hitPointWorld, playerSize * 0.3, 0.2);

				var grappleBody = new cannon.Body({
					type: cannon.Body.STATIC,
					position: this.player.crosshair2.worldToLocal(new three.Vector3()).toCannon(), // m 
				});
				this.world.world.addBody(grappleBody);

				var spring = new cannon.Spring(grappleBody, body, {
					restLength: 0,
					localAnchorA: new cannon.Vec3(),
					localAnchorB: new cannon.Vec3()
				});

				var geom = new three.SphereGeometry(0.5, 16, 8);
				var t = 0;
				geom.vertices.forEach(v => {
					v.y += 0.5;
					t = v.z;
					v.z = v.y;
					v.y = t;
				});
				var mat = new three.MeshBasicMaterial({
					wireframe: true
				});

				var effect = new three.Mesh(geom, mat);
				this.world.scene.add(effect);

				this.spring = spring;
				this.grappleBody = grappleBody;
				this.effect = effect;
				this.world.world.addEventListener("postStep", this.onCannonPostStep);
			}
		}
	}
}

function primaryFireEnd(pos, playerSize) {
	if(this.spring) {
		this.spring = null;
		this.world.world.removeEventListener("postStep", this.onCannonPostStep);
		this.world.world.removeBody(this.grappleBody);
		this.effect.parent.remove(this.effect);
	}
}

function onCannonPostStep(event) {
	this.grappleBody.position.copy(this.player.crosshair2.localToWorld(new three.Vector3()));
	this.spring.applyForce();
}

function onEnterFrame() {
	var tool = this.player.activeTool;
	if(this.spring && tool) {
		this.effect.position.copy(tool.mesh.localToWorld(tool.nozzle.clone()));
		var target = this.spring.bodyB.position.toThree();
		this.effect.lookAt(target);
		var stretch = this.effect.position.clone().sub(target).length();
		var squash = 1 / stretch;
		this.effect.scale.set(squash, squash, stretch);
	}
}

module.exports = HitScanGrappleHook;